#name: CI
#
#on:
#  push:
#
#
#jobs:
#  static-analysis:  # mypy, black, ruff 등 정적 분석
#    runs-on: ubuntu-22.04  # 가상 운영체제 환경에서 실행됨. 실제 프롣덕션(배포)환경에서는 모든 버전을 고정하는 것이 좋다.
#    # 예기치 못하게 버전이 올라가서 장애가 생기는 것을 막기 위해 버전을 고정
#    steps:
#      # 가장 최신 브랜치와 커밋을 가져옴
#      - name: Check out the codes
#        uses: actions/checkout@v2
#
#      - name: Setup python environment
#        id: setup-python
#        uses: actions/setup-python@v2
#        with:
#          python-version: "3.13"
#
#      # 캐시 기능을 사용해 매번 설치하는 낭비를 줄임
#      # key와 path는 필수
#      - name: Cache Poetry
#        id: cache-poetry
#        uses: actions/cache@v3
#        with:
#          key: poetry-2.1.2  # 	캐시 구분용 키 (버전별로 다르게 구분)
#          path: ~/.local/   # poetry는 ~/.local에 설치되므로, 이 디렉터리를 통째로 캐시할 것입니다.
#
#
#      - name: Install Poetry
#        # 캐시를 못 쓰는 경우에만 설치
#        if: steps.cache-poetry.outputs.cache-hit != 'true'
#        run: |
#          curl -sSL https://install.python-poetry.org | python3 - --version 2.1.2
#
#      # poetry를 사용하기 위해 설정
#      - name: Register Poetry bin
#        run: echo "${HOME}/.poetry/bin" >> $GITHUB_PATH
#
#      - name: Cache dependencies
#        id: cache-venv
#        uses: actions/cache@v3
#        with:
#          # 전체 파일을 비교하는 것보다 hash값만 비교하는게 빠름.
#          key: python-${{ steps.setup-python.outputs.python-version }}-poetry-lock-${{ hashFiles('poetry.lock') }}-toml-${{ hashFiles('pyproject.toml') }}-poetry-2.1.2
#          path: /home/runner/.cache/pypoetry/virtualenvs/
#
#      - name: Install dependencies
#        # 캐시를 못 쓰는 경우에만 설치
#        if: steps.cache-venv.outputs.cache-hit != 'true'
#        run: poetry install --no-root
#
#      # 코드 포메터 (black)으로 체크만 함.
#      - name: Run Black
#        run: poetry run black . --check
#
#      - name: Run Ruff
#        run: |
#          poetry run ruff check --select I
#          poetry run ruff check
#
#      - name: Run Mypy
#        run: poetry run mypy .
#
#  test:   # 전체 테스트 실행
#    runs-on: ubuntu-22.04
#
#    env:
#      MYSQL_HOST: 127.0.0.1
#      MYSQL_PORT: 3306
#      MYSQL_USER: root
#      MYSQL_PASSWORD: 1234
#      MYSQL_DATABASE: when2meet_vod
#
#    steps:
#      - name: Check out the codes
#        uses: actions/checkout@v2
#
#      - name: Setup python environment
#        id: setup-python
#        uses: actions/setup-python@v2
#        with:
#          python-version: "3.13"
#
#      # 캐시 기능을 사용해 매번 설치하는 낭비를 줄임
#      # key와 path는 필수
#      - name: Cache Poetry
#        id: cache-poetry
#        uses: actions/cache@v3
#        with:
#          key: poetry-2.1.2  # 	캐시 구분용 키 (버전별로 다르게 구분)
#          path: ~/.local/   # poetry는 ~/.local에 설치되므로, 이 디렉터리를 통째로 캐시할 것입니다.
#
#      - name: Install Poetry
#        # 캐시를 못 쓰는 경우에만 설치
#        if: steps.cache-poetry.outputs.cache-hit != 'true'
#        run: |
#          curl -sSL https://install.python-poetry.org | python3 - --version 2.1.2
#
#      - name: Register Poetry bin
#        run: echo "${HOME}/.poetry/bin" >> $GITHUB_PATH
#
#      - name: Cache dependencies
#        id: cache-venv
#        uses: actions/cache@v3
#        with:
#          # 전체 파일을 비교하는 것보다 hash값만 비교하는게 빠름.
#          key: python-${{ steps.setup-python.outputs.python-version }}-poetry-lock-${{ hashFiles('poetry.lock') }}-toml-${{ hashFiles('pyproject.toml') }}-poetry-2.1.2
#          path: /home/runner/.cache/pypoetry/virtualenvs/
#
#      - name: Install dependencies
#        # 캐시를 못 쓰는 경우에만 설치
#        if: steps.cache-venv.outputs.cache-hit != 'true'
#        run: poetry install --no-root
#
#      # /etc/localtime 파일은 현재 시스템의 시간대 정보를 담고 있는 심볼릭 링크. 이 파일을 삭제해서 시간대 설정을 초기화하려는 의도
#      # sudo ln -s 새롭게 한국 시간대(KST) 에 맞는 타임존 파일을 /etc/localtime에 심볼릭 링크로 연결
#      - name: Set timezone to KST
#        run: |  # | 뒤에 오는 줄들은 모두 한 덩어리의 스크립트로 실행됩니다 (여러 줄 가능)
#          sudo rm /etc/localtime
#          sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime
#
#      # 깃허브에는 mysql이 이미 설치 되어 있어서 실행만 하면됨.
#      - name: Start Mysql
#        run: |  # | (파이프라인) 은 yaml 문법인데, value 를 multi-line 으로 쓰고 싶을때 사용합니다.
#          sudo systemctl start mysql
#          mysql -e "use mysql; FLUSH PRIVILEGES; ALTER USER '${{ env.MYSQL_USER }}'@'localhost' IDENTIFIED BY '${{ env.MYSQL_PASSWORD }}';" -uroot -proot
#          mysql -e 'CREATE DATABASE ${{ env.MYSQL_DATABASE }};' -u${{ env.MYSQL_USER }} -p${{ env.MYSQL_PASSWORD }}
#
#      #mysql -e
#      #→ MySQL 커맨드라인 클라이언트를 실행하며 -e 옵션은 즉석에서 쿼리를 실행합니다.
#      #
#      #"use mysql; ..."
#      #→ 먼저 시스템 DB인 mysql을 사용한 후, 권한 갱신 및 사용자 비밀번호를 변경합니다.
#      #
#      #FLUSH PRIVILEGES;
#      #→ 권한 변경 사항을 MySQL에 즉시 반영합니다.
#      #
#      #ALTER USER ... IDENTIFIED BY ...
#      #→ 환경 변수 ${{ env.MYSQL_USER }} 와 ${{ env.MYSQL_PASSWORD }}를 사용해
#      #해당 사용자에 대해 비밀번호를 재설정합니다.
#      #(CI 환경에선 초기 사용자 세팅이 필요하기 때문에 이 설정이 중요합니다)
#      #
#      #-uroot -proot
#      #→ MySQL의 root 계정으로 로그인합니다. 비밀번호는 root.
#
##      - name: Run tests
##        run: |
##          poetry run coverage run -m pytest .
##          poetry run coverage report -m
#
#      # 테스트 파일이 있는 경우에만 실행
##      - name: Run tests only if test files exist
##        run: |
##          if find . -type f -name 'test_*.py' | grep -q .; then
##            echo "✅ Test files found. Running pytest..."
##            poetry run coverage run -m pytest .
##            poetry run coverage report -m
##          else
##            echo "⚠️ No test files found. Skipping tests."
##          fi
#
#      # 실제로 테스트 할 수 있는 코드가 있는지 판별 후 테스트 수행
#      - name: Run tests only if tests actually exist
#        run: |
#          echo "🔍 Checking if pytest can collect any tests..."
#          TEST_COUNT=$(poetry run pytest --collect-only -q 2>/dev/null | grep -c '::' || true)
#
#          if [ "$TEST_COUNT" -gt 0 ]; then
#            echo "✅ Found $TEST_COUNT tests. Running pytest..."
#            poetry run coverage run -m pytest .
#            poetry run coverage report -m
#          else
#            echo "⚠️ No runnable tests found. Skipping pytest."
#          fi
#
#      # pytest --collect-only : 테스트 수집
#      # pytest --collect-only -q: 테스트 목록만 출력
#      # grep -c '::': 테스트 개수 세기
#      # poetry run pytest ... || true → 테스트 없어서 실패해도 정상 종료 처리 (최종 종료 코드는 0)
#      # grep -c '::'로 실제 수집 가능한 테스트 개수를 정확히 판별
#
#      # 테스트가 없는 경우 pytest는 종료 코드를 5로 반환합니다 → "수행할 테스트가 없음"
#      # GitHub Actions는 0이 아닌 모든 종료 코드를 실패로 간주
#
#      # pytest 종료 코드 (exit code)
#      # 0	테스트 성공 (모든 테스트 통과)
#      # 1	테스트 실패 (어떤 테스트든 실패함)
#      # 2	사용법 에러 (예: 잘못된 인자)
#      # 3	내부 에러
#      # 4	pytest 플러그인 에러
#      # 5	테스트 없음 (no tests collected)